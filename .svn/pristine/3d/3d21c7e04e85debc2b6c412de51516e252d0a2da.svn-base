using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace Maticsoft.BLL.ScanPortImage
{
    class ScanPortImageUtil
    {
        private const int startPointX = 9,
            startPointY = 50,
            b2bHigh = 34,
            b2sHigh = 16,
            bHigh = 10,
            sHigh = 8,
            bWidth = 30,
            sWidth = 30,
            b2sWidth = 10,
            s2sWidth = 12;
        public static Bitmap creatScanPortImage()
        {
            //第一步：计算整个图片的高度(头上高度——文字内容加部分空白预留、扫描部分、尾部高度)
            Bitmap imgTemp = new Bitmap(640, 800);
            Graphics g = Graphics.FromImage(imgTemp); //创建画板
            g.Clear(Color.White);
            Pen bigp = new Pen(Color.Black, bHigh);//大黑块画笔
            Pen smallp = new Pen(Color.Black, sHigh);//小黑块画笔
            //第二步：写入订单信息
            g.DrawString("订单:000001,彩票编号:000001     北京彩游天下", SystemFonts.DefaultFont, SystemBrushes.ControlText, new Point(30, 10));
            //第三步：绘制一张未填入打印内容的图片
            creatBlankScanPortImage(imgTemp, g, bigp, smallp);
            //第四步：填入打印内容

            //g.DrawLine(bigp, 0, 200, 640, 200);//在画板上画直线,开始标识
            //g.DrawLine(p, 10, 20, 20, 20);//在画板上画直线,起始坐标为(10,10),终点坐标为(100,100)
            //g.DrawLine(p, 10, 30, 20, 30);//在画板上画直线,起始坐标为(10,10),终点坐标为(100,100)
            //g.DrawLine(p, 10, 40, 20, 40);//在画板上画直线,起始坐标为(10,10),终点坐标为(100,100)
            //g.DrawLine(p, 10, 50, 20, 50);//在画板上画直线,起始坐标为(10,10),终点坐标为(100,100)
            //g.DrawRectangle(p1, 0, 0, 575, 799);//在画板上画矩形,起始坐标为(10,10),宽为,高为
            //g.DrawEllipse(p, 10, 10, 100, 100);//在画板上画椭圆,起始坐标为(10,10),外接矩形的宽为,高为
            //Bitmap imgTemp001 = (Bitmap)Image.FromFile("C:\\Users\\zlpng\\Desktop\\testprint02.bmp");

            //imgTemp.Save("C:\\Users\\zlpng\\Desktop\\testprint02.bmp");
            //Image imgTemp2 = new Bitmap(576, 800, PixelFormat.Format1bppIndexed);

            return FaqCopyTo1bpp(imgTemp);
        }

        /// <summary>
        /// 绘制一张空白图——现在暂时以竞彩篮球大小分3关为例、以后是要传入彩票对象来绘制
        /// </summary>
        /// <param name="bmp"></param>
        /// <param name="g"></param>
        /// <param name="bigp"></param>
        /// <param name="smallp"></param>
        private static void creatBlankScanPortImage(Bitmap bmp, Graphics g, Pen bigp, Pen smallp)
        {
            String[] playCode = new String[] { "110011001110" };

            //第一步：开始标识
            g.DrawLine(bigp, startPointX, startPointY, startPointX + bWidth, startPointY);
            //第二步：绘制玩法
            for (int i = 0; i < playCode.Length; i++)
            {
                for (int j = 0; j < playCode[i].Length; j++)
                {
                    if (playCode[i][j] == '1')
                    {
                        g.DrawLine(smallp, (startPointX + bWidth + b2sWidth) + j * (sWidth + s2sWidth) + (j / 3) * 2, (startPointY + bHigh + b2sHigh) + i * (b2bHigh + bHigh),
                        (startPointX + bWidth + b2sWidth) + j * (sWidth + s2sWidth) + (j / 3) * 2 + sWidth, (startPointY + bHigh + b2sHigh) + i * (b2bHigh + bHigh));
                    }
                }

                g.DrawLine(bigp, startPointX, startPointY + (i + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (i + 1) * (b2bHigh + bHigh));
            }

            g.DrawLine(bigp, startPointX, startPointY + (1 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (1 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (2 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (2 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (3 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (3 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (4 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (4 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (5 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (5 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (6 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (6 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (7 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (7 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (8 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (8 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (9 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (9 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (10 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (10 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (11 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (11 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (12 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (12 + 1) * (b2bHigh + bHigh));
            g.DrawLine(bigp, startPointX, startPointY + (13 + 1) * (b2bHigh + bHigh), startPointX + bWidth, startPointY + (13 + 1) * (b2bHigh + bHigh));

            g.DrawLine(bigp, 640 - bWidth, startPointY + (14 + 1) * (b2bHigh + bHigh), 640, startPointY + (14 + 1) * (b2bHigh + bHigh));
        }

        /// <summary>
        /// 把图片转换成1位深度的黑白图
        /// </summary>
        /// <param name="b"></param>
        /// <returns></returns>
        private static System.Drawing.Bitmap FaqCopyTo1bpp(System.Drawing.Bitmap b)
        {
            int w = b.Width, h = b.Height;
            System.Drawing.Rectangle r = new System.Drawing.Rectangle(0, 0, w, h);
            if (b.PixelFormat != System.Drawing.Imaging.PixelFormat.Format32bppPArgb)
            {
                System.Drawing.Bitmap temp = new System.Drawing.Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);
                System.Drawing.Graphics g = System.Drawing.Graphics.FromImage(temp);
                g.DrawImage(b, r, 0, 0, w, h, System.Drawing.GraphicsUnit.Pixel);
                g.Dispose();
                b = temp;
            }
            System.Drawing.Imaging.BitmapData bdat = b.LockBits(r, System.Drawing.Imaging.ImageLockMode.ReadOnly, b.PixelFormat);
            System.Drawing.Bitmap b0 = new System.Drawing.Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format1bppIndexed);
            System.Drawing.Imaging.BitmapData b0dat = b0.LockBits(r, System.Drawing.Imaging.ImageLockMode.ReadWrite, System.Drawing.Imaging.PixelFormat.Format1bppIndexed);
            for (int y = 0; y < h; y++)
            {
                for (int x = 0; x < w; x++)
                {
                    int index = y * bdat.Stride + (x * 4);
                    if (System.Drawing.Color.FromArgb(System.Runtime.InteropServices.Marshal.ReadByte(bdat.Scan0, index + 2), System.Runtime.InteropServices.Marshal.ReadByte(bdat.Scan0, index + 1), System.Runtime.InteropServices.Marshal.ReadByte(bdat.Scan0, index)).GetBrightness() > 0.5f)
                    {
                        int index0 = y * b0dat.Stride + (x >> 3);
                        byte p = System.Runtime.InteropServices.Marshal.ReadByte(b0dat.Scan0, index0);
                        byte mask = (byte)(0x80 >> (x & 0x7));
                        System.Runtime.InteropServices.Marshal.WriteByte(b0dat.Scan0, index0, (byte)(p | mask));
                    }
                }
            }
            b0.UnlockBits(b0dat);
            b.UnlockBits(bdat);
            return b0;
        }
    }
}
