using Maticsoft.Common.model;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace Maticsoft.BLL.ScanPortImage
{
    public class ScanPortImageUtil
    {
        public static Bitmap creatScanPortImage(lottery_ticket lt,int times)
        {
            SPImageStructure spis = SPImageGlobal.SPISTRUCTURE_DICTIONARY[getSPIKey(lt)];
            //第一步：计算整个图片的高度(头上高度——文字内容加部分空白预留、扫描部分、尾部高度)
            Bitmap imgTemp = new Bitmap(640, spis.getStructureHigh()+200);
            Graphics g = Graphics.FromImage(imgTemp); //创建画板
            g.Clear(Color.White);
            Pen bigp = new Pen(Color.Black, 11.7f);//大黑块画笔
            Pen smallp = new Pen(Color.Black, SPImageGlobal.SMALL_BB_HIGH);//小黑块画笔
            Pen bigp2 = new Pen(Color.Black, 11.5f);//小黑块画笔
            //第二步：写入订单信息
            g.DrawString(lt.multiple+"倍"+lt.bet_price+"元", new Font("宋体", 40, FontStyle.Bold, GraphicsUnit.Pixel), SystemBrushes.ControlText, new Point(300, 2));
            g.DrawString("订单:" + lt.order_id + "," + lt.ticket_id + "-" + times + "\n[" + getShowName(lt.username)+"]", new Font("宋体", 25, FontStyle.Bold, GraphicsUnit.Pixel), SystemBrushes.ControlText, new Point(10, 2));
            //第三步：绘制一张未填入打印内容的图片
            creatBlankScanPortImage(imgTemp, g, bigp, smallp, spis);
            //第四步：填入打印内容
            drawBetContent(imgTemp, g, bigp2, spis.getDrawPoints(lt));

            return FaqCopyTo1bpp(imgTemp);
        }

        /// <summary>
        /// 取可显示的用户名
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        private static string getShowName(string p)
        {
            return p.Substring(0,1)+"****"+(p.Length>4?p.Substring(p.Length-5,4):p.Substring(1));
        }

        /// <summary>
        /// 通过彩票对象取得对应的票面结构字典的key值
        /// </summary>
        /// <param name="lt"></param>
        /// <returns></returns>
        private static string getSPIKey(lottery_ticket lt)
        {
            if (lt.play_type.Contains("-"))//竞彩
            {
                String[] p = lt.play_type.Split('-');
                int m = 3;
                int.TryParse(p[1].Replace("null", "1c1").Split('c')[0], out m);
                if (m==1)//有可能是单关选了多场
                {
                    m = lt.bet_code.Split('|').Length;
                }
                if (lt.license_id == 9)
                {         
                    return lt.license_id + "_" + (p[0].Equals("2") ? "6" : p[0]) + "_" + (m <= 3 ? 3 : (m <= 6 ? 6 : 8));
                }
                else
                {
                    return lt.license_id + "_" + p[0] + "_" + (m <= 3 ? 3 : (m <= 6 ? 6 : 8));
                }
                
            }
            else
            {
                if (lt.license_id == 5 || lt.license_id == 6)
                {
                    return "5_6_1";
                }
                else if (lt.license_id == 3 || lt.license_id == 7 || lt.license_id == 8)
                {
                    return lt.license_id + "_1_2";
                }
                else if (lt.license_id == 4)
                {
                    return lt.license_id + (lt.play_type.Equals("3")?"_0_3":"_1_2");
                }
                else if (lt.license_id == 2 || lt.license_id == 1)
                {
                    return "2_1_2";
                }
                return lt.license_id + "_" + lt.play_type;
            }
        }

        /// <summary>
        /// 绘制投注内容的点
        /// </summary>
        /// <param name="imgTemp"></param>
        /// <param name="g"></param>
        /// <param name="smallp"></param>
        /// <param name="list"></param>
        private static void drawBetContent(Bitmap imgTemp, Graphics g, Pen smallp, List<Point> list)
        {
            foreach (Point item in list)
            {
                g.DrawLine(smallp, item.X, item.Y + (int)Math.Floor((item.Y - SPImageGlobal.START_POINT_Y) / (6d * SPImageGlobal.BB_HIGH)), item.X + SPImageGlobal.BB_WIDTH - 2,
                    item.Y + (int)Math.Floor((item.Y - SPImageGlobal.START_POINT_Y) / (6d * SPImageGlobal.BB_HIGH)));
            }
        }

        /// <summary>
        /// 绘制一张空白图——现在暂时以竞彩篮球大小分3关为例、以后是要传入彩票对象来绘制
        /// </summary>
        /// <param name="bmp"></param>
        /// <param name="g"></param>
        /// <param name="bigp"></param>
        /// <param name="smallp"></param>
        private static void creatBlankScanPortImage(Bitmap bmp, Graphics g, Pen bigp, Pen smallp, SPImageStructure spis)
        {
            String[] playCode = spis.getPTypeHeadDesc();
            //第一步：开始标识、左边黑线、结束标识
            int endy = 0;
            g.DrawLine(bigp, SPImageGlobal.START_POINT_X, SPImageGlobal.START_POINT_Y,
                SPImageGlobal.START_POINT_X + SPImageGlobal.BB_WIDTH, SPImageGlobal.START_POINT_Y);
            for (int i = 1; i <= spis.getStructureHigh()/SPImageGlobal.BB_HIGH; i++)
            {
                endy = SPImageGlobal.START_POINT_Y + i * SPImageGlobal.BB_HIGH + (int)Math.Floor(i / 6d);

                g.DrawLine(bigp, SPImageGlobal.START_POINT_X, endy,
                 SPImageGlobal.START_POINT_X + SPImageGlobal.BB_WIDTH, endy); 
            }

            bigp.Width += 4;
            g.DrawLine(bigp, 640 - SPImageGlobal.BB_WIDTH-10,endy + SPImageGlobal.BB_WIDTH, 640,endy + SPImageGlobal.BB_WIDTH);
            //第二步：绘制玩法
            for (int i = 0; i < playCode.Length; i++)
            {
                for (int j = 0; j < playCode[i].Length; j++)
                {
                    if (playCode[i][j] == '1')
                    {
                        g.DrawLine(smallp, SPImageGlobal.LEFT_SMALL_BB_X + j * SPImageGlobal.S2S_WIDTH,
                            SPImageGlobal.START_POINT_Y + i * SPImageGlobal.BB_HIGH+SPImageGlobal.B2S_HIGH,
                        SPImageGlobal.LEFT_SMALL_BB_X + j * SPImageGlobal.S2S_WIDTH + SPImageGlobal.BB_WIDTH,
                        SPImageGlobal.START_POINT_Y + i * SPImageGlobal.BB_HIGH + SPImageGlobal.B2S_HIGH);
                    }
                }
            }
        }

        /// <summary>
        /// 把图片转换成1位深度的黑白图
        /// </summary>
        /// <param name="b"></param>
        /// <returns></returns>
        private static System.Drawing.Bitmap FaqCopyTo1bpp(System.Drawing.Bitmap b)
        {
            int w = b.Width, h = b.Height;
            System.Drawing.Rectangle r = new System.Drawing.Rectangle(0, 0, w, h);
            if (b.PixelFormat != System.Drawing.Imaging.PixelFormat.Format32bppPArgb)
            {
                System.Drawing.Bitmap temp = new System.Drawing.Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);
                System.Drawing.Graphics g = System.Drawing.Graphics.FromImage(temp);
                g.DrawImage(b, r, 0, 0, w, h, System.Drawing.GraphicsUnit.Pixel);
                g.Dispose();
                b = temp;
            }
            System.Drawing.Imaging.BitmapData bdat = b.LockBits(r, System.Drawing.Imaging.ImageLockMode.ReadOnly, b.PixelFormat);
            System.Drawing.Bitmap b0 = new System.Drawing.Bitmap(w, h, System.Drawing.Imaging.PixelFormat.Format1bppIndexed);
            System.Drawing.Imaging.BitmapData b0dat = b0.LockBits(r, System.Drawing.Imaging.ImageLockMode.ReadWrite, System.Drawing.Imaging.PixelFormat.Format1bppIndexed);
            for (int y = 0; y < h; y++)
            {
                for (int x = 0; x < w; x++)
                {
                    int index = y * bdat.Stride + (x * 4);
                    if (System.Drawing.Color.FromArgb(System.Runtime.InteropServices.Marshal.ReadByte(bdat.Scan0, index + 2), System.Runtime.InteropServices.Marshal.ReadByte(bdat.Scan0, index + 1), System.Runtime.InteropServices.Marshal.ReadByte(bdat.Scan0, index)).GetBrightness() > 0.5f)
                    {
                        int index0 = y * b0dat.Stride + (x >> 3);
                        byte p = System.Runtime.InteropServices.Marshal.ReadByte(b0dat.Scan0, index0);
                        byte mask = (byte)(0x80 >> (x & 0x7));
                        System.Runtime.InteropServices.Marshal.WriteByte(b0dat.Scan0, index0, (byte)(p | mask));
                    }
                }
            }
            b0.UnlockBits(b0dat);
            b.UnlockBits(bdat);
            return b0;
        }
    }
}
